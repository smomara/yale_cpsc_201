# Lecture 2: Racket.

Materials covered in Lecture 2:
* Collatz Notebook
    * [Collatz.ipynb](Collatz.ipynb)
* Collatz Racket
    * [collatz.rkt](collatz.rkt)
* Racket Notes up to Rule 2 of Evaluating Expressions
    * [Racket](racket.md)

### The Big Picture

There is a standard scheme for giving a talk.

1.  Tell the audience what you plan to tell them.
2.  Tell them.
3.  Tell them what you told them.

Today we are at step 1.

To some of you, the organization of topics in this course may seem hazy, like the shadows in Plato's cave. I want to assure you that, like in [Blackadder](https://en.wikipedia.org/wiki/Blackadder), there is a cunning plan.

> For years, academic computer scientists have debated the role of programming in introductory computer science courses. Many have argued that an introductory science course should expose the student to the great ideas of the discipline. Thus, an introductory biology course should cover topics such as evolution and molecular genetics, but not how to build a microscope. Accordingly, a computer science course should emphasize the major intellectual issues of computing, not how to write programs.
> 
> We do not agree with this position. First, programming is a major intellectual issue in computer science. Second, the comparison of programming to building a microscope misses the point. Writing programs in computer science is more like building a living organism in biology. If biology had advanced to a stage that permitted introductory students easily to construct amoebas and clams and roses and rabbits, there would be little debate over the intellectual content of such exercises. (Slade, _The T Programming Language_, 1987)

Here is the our framework.

*   Progamming and recursion. Learning racket allows us to have a grounded conversation.
*   Turing Machines. What are the limits to computing?
*   Boolean functions. What are the logical atomic elements of computation on which machines are built?
*   Gates and circuits. How do we wire up circuits?
*   TC 201 and computer architecture. How do we build a computer?
*   Strings and formal languages. How do we translate high level source code into machine language?
*   Computational complexity. Being computable is not sufficient if the algorithm is not efficient. How do we analyze algorithms?

For the next few months, we will execute step 2. On April 28th, I will execute step 3.

Note: there are three other rules for public speaking...

### Racket

[Collatz.ipynb](Collatz.ipynb) [collatz.rkt](collatz.rkt)
[Racket](racket.md)

#### Getting to know UNIX

[UNIX Introduction](UNIX.md)